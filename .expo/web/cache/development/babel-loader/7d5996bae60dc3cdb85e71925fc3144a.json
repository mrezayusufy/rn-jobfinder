{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { getNameFromFilePath, matchDeepDynamicRouteName, matchDynamicName, matchGroupName, removeSupportedExtensions, stripGroupSegmentsFromPath, stripInvisibleSegmentsFromPath } from \"./matchers\";\nexport function getRecursiveTree(files) {\n  var tree = {\n    name: \"\",\n    children: [],\n    parents: [],\n    node: null\n  };\n  for (var file of files) {\n    var parts = file.normalizedName.split(\"/\");\n    var currentNode = tree;\n    var _loop = function _loop() {\n      var part = parts[i];\n      if (i === parts.length - 1 && part === \"_layout\") {\n        if (currentNode.node) {\n          var overwritten = currentNode.node.contextKey;\n          throw new Error(\"Higher priority Layout Route \\\"\" + file.contextKey + \"\\\" overriding redundant Layout Route \\\"\" + overwritten + \"\\\". Remove the Layout Route \\\"\" + overwritten + \"\\\" to fix this.\");\n        }\n        return \"continue\";\n      }\n      var existing = currentNode.children.find(function (item) {\n        return item.name === part;\n      });\n      if (existing) {\n        currentNode = existing;\n      } else {\n        var newNode = {\n          name: part,\n          children: [],\n          parents: [].concat(_toConsumableArray(currentNode.parents), [currentNode.name]),\n          node: null\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    };\n    for (var i = 0; i < parts.length; i++) {\n      var _ret = _loop();\n      if (_ret === \"continue\") continue;\n    }\n    currentNode.node = file;\n  }\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDeprecatedFormat(tree);\n  }\n  return tree;\n}\nfunction assertDeprecatedFormat(tree) {\n  for (var child of tree.children) {\n    if (child.node && child.children.length && !child.node.normalizedName.endsWith(\"_layout\")) {\n      var ext = child.node.contextKey.split(\".\").pop();\n      throw new Error(\"Using deprecated Layout Route format: Move `./app/\" + child.node.normalizedName + \".\" + ext + \"` to `./app/\" + child.node.normalizedName + \"/_layout.\" + ext + \"`\");\n    }\n    assertDeprecatedFormat(child);\n  }\n}\nfunction getTreeNodesAsRouteNodes(nodes) {\n  return nodes.map(function (node) {\n    return treeNodeToRouteNode(node);\n  }).flat().filter(Boolean);\n}\nexport function generateDynamicFromSegment(name) {\n  var deepDynamicName = matchDeepDynamicRouteName(name);\n  var dynamicName = deepDynamicName != null ? deepDynamicName : matchDynamicName(name);\n  return dynamicName ? {\n    name: dynamicName,\n    deep: !!deepDynamicName\n  } : null;\n}\nexport function generateDynamic(name) {\n  var description = name.split(\"/\").map(function (segment) {\n    return generateDynamicFromSegment(segment);\n  }).filter(Boolean);\n  return description.length === 0 ? null : description;\n}\nfunction collapseRouteSegments(route) {\n  return stripGroupSegmentsFromPath(route.replace(/\\/index$/, \"\"));\n}\n\nfunction getDefaultInitialRoute(node, name) {\n  return node.children.find(function (node) {\n    return collapseRouteSegments(node.route) === name;\n  });\n}\nfunction applyDefaultInitialRouteName(node) {\n  var _node$children, _getDefaultInitialRou;\n  var groupName = matchGroupName(node.route);\n  if (!((_node$children = node.children) != null && _node$children.length)) {\n    return node;\n  }\n\n  var initialRouteName = groupName ? (_getDefaultInitialRou = getDefaultInitialRoute(node, groupName)) == null ? void 0 : _getDefaultInitialRou.route : undefined;\n  var loaded = node.loadRoute();\n  if (loaded.unstable_settings) {\n    var _loaded$unstable_sett;\n    initialRouteName = (_loaded$unstable_sett = loaded.unstable_settings.initialRouteName) != null ? _loaded$unstable_sett : initialRouteName;\n    if (groupName) {\n      var _loaded$unstable_sett2, _loaded$unstable_sett3;\n      var groupSpecificInitialRouteName = (_loaded$unstable_sett2 = loaded.unstable_settings) == null ? void 0 : (_loaded$unstable_sett3 = _loaded$unstable_sett2[groupName]) == null ? void 0 : _loaded$unstable_sett3.initialRouteName;\n      initialRouteName = groupSpecificInitialRouteName != null ? groupSpecificInitialRouteName : initialRouteName;\n    }\n  }\n  return _objectSpread(_objectSpread({}, node), {}, {\n    initialRouteName: initialRouteName\n  });\n}\nfunction cloneGroupRoute(node, _ref) {\n  var nextName = _ref.name;\n  var groupName = \"(\" + nextName + \")\";\n  var parts = node.contextKey.split(\"/\");\n  parts[parts.length - 2] = groupName;\n  return _objectSpread(_objectSpread({}, node), {}, {\n    route: groupName,\n    contextKey: parts.join(\"/\")\n  });\n}\nfunction folderNodeToRouteNode(_ref2) {\n  var name = _ref2.name,\n    children = _ref2.children;\n  if (!children.length) {\n    return null;\n  }\n\n  return getTreeNodesAsRouteNodes(children.map(function (child) {\n    return _objectSpread(_objectSpread({}, child), {}, {\n      name: [name, child.name].filter(Boolean).join(\"/\")\n    });\n  }));\n}\nfunction fileNodeToRouteNode(tree) {\n  var name = tree.name,\n    node = tree.node,\n    children = tree.children;\n  if (!node) throw new Error(\"node must be defined\");\n  var dynamic = generateDynamic(name);\n  var groupName = matchGroupName(name);\n  var multiGroup = groupName == null ? void 0 : groupName.includes(\",\");\n  var clones = multiGroup ? groupName.split(\",\").map(function (v) {\n    return {\n      name: v.trim()\n    };\n  }) : null;\n\n  if (clones) {\n    var names = new Set();\n    for (var clone of clones) {\n      if (names.has(clone.name)) {\n        throw new Error(\"Array syntax cannot contain duplicate group name \\\"\" + clone.name + \"\\\" in \\\"\" + node.contextKey + \"\\\".\");\n      }\n      names.add(clone.name);\n    }\n  }\n  var output = {\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic: dynamic\n  };\n  if (Array.isArray(clones)) {\n    return clones.map(function (clone) {\n      return applyDefaultInitialRouteName(cloneGroupRoute(_objectSpread({}, output), clone));\n    });\n  }\n  return [applyDefaultInitialRouteName({\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic: dynamic\n  })];\n}\nfunction treeNodeToRouteNode(tree) {\n  if (tree.node) {\n    return fileNodeToRouteNode(tree);\n  }\n  return folderNodeToRouteNode(tree);\n}\nfunction contextModuleToFileNodes(contextModule) {\n  var files = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : contextModule.keys();\n  var nodes = files.map(function (key) {\n    try {\n      if (process.env.NODE_ENV === \"development\") {\n        if (\"sync\" === \"sync\") {\n          var _contextModule;\n          if (!((_contextModule = contextModule(key)) != null && _contextModule.default)) {\n            return null;\n          }\n        }\n      }\n      var node = {\n        loadRoute: function loadRoute() {\n          return contextModule(key);\n        },\n        normalizedName: getNameFromFilePath(key),\n        contextKey: key\n      };\n      return node;\n    } catch (error) {\n      console.warn('Error loading route \"' + key + '\"', error);\n    }\n    return null;\n  });\n  return nodes.filter(Boolean);\n}\nfunction hasCustomRootLayoutNode(routes) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  var route = routes[0];\n  if (route.route === \"\" && route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)) {\n    return true;\n  }\n  return false;\n}\nfunction treeNodesToRootRoute(treeNode) {\n  var routes = treeNodeToRouteNode(treeNode);\n  return withOptionalRootLayout(routes);\n}\nfunction processKeys(files, options) {\n  var ignore = options.ignore;\n  return files.filter(function (file) {\n    return !(ignore != null && ignore.some(function (pattern) {\n      return pattern.test(file);\n    }));\n  });\n}\n\nexport function assertDuplicateRoutes(filenames) {\n  if (process.env.NODE_ENV === \"production\") {\n    return;\n  }\n  var duplicates = filenames.map(function (filename) {\n    return removeSupportedExtensions(filename);\n  }).reduce(function (acc, filename) {\n    acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n    return acc;\n  }, {});\n  Object.entries(duplicates).forEach(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      filename = _ref4[0],\n      count = _ref4[1];\n    if (count > 1) {\n      throw new Error(\"Multiple files match the route name \\\"\" + filename + \"\\\".\");\n    }\n  });\n}\n\nexport function getRoutes(contextModule, options) {\n  var route = getExactRoutes(contextModule, options);\n  if (!route) {\n    return null;\n  }\n  appendSitemapRoute(route);\n\n  appendUnmatchedRoute(route);\n  return route;\n}\nexport function getRoutesAsync(_x, _x2) {\n  return _getRoutesAsync.apply(this, arguments);\n}\nfunction _getRoutesAsync() {\n  _getRoutesAsync = _asyncToGenerator(function* (contextModule, options) {\n    var route = yield getExactRoutesAsync(contextModule, options);\n    if (!route) {\n      return null;\n    }\n    appendSitemapRoute(route);\n\n    appendUnmatchedRoute(route);\n    return route;\n  });\n  return _getRoutesAsync.apply(this, arguments);\n}\nfunction getIgnoreList(options) {\n  var _options$ignore;\n  var ignore = [/^\\.\\/\\+html\\.[tj]sx?$/].concat(_toConsumableArray((_options$ignore = options == null ? void 0 : options.ignore) != null ? _options$ignore : []));\n  return ignore;\n}\n\nexport function getExactRoutes(contextModule, options) {\n  var treeNodes = contextModuleToTree(contextModule, options);\n  var route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\nfunction contextModuleToTree(contextModule, options) {\n  var allowed = processKeys(contextModule.keys(), _objectSpread(_objectSpread({}, options), {}, {\n    ignore: getIgnoreList(options)\n  }));\n  assertDuplicateRoutes(allowed);\n  var files = contextModuleToFileNodes(contextModule, allowed);\n  return getRecursiveTree(files);\n}\nexport function getExactRoutesAsync(_x3, _x4) {\n  return _getExactRoutesAsync.apply(this, arguments);\n}\nfunction _getExactRoutesAsync() {\n  _getExactRoutesAsync = _asyncToGenerator(function* (contextModule, options) {\n    var treeNodes = contextModuleToTree(contextModule, options);\n    var route = treeNodesToRootRoute(treeNodes);\n    return route || null;\n  });\n  return _getExactRoutesAsync.apply(this, arguments);\n}\nfunction appendSitemapRoute(routes) {\n  if (!routes.children.length ||\n  routes.children.some(function (route) {\n    return route.route === \"_sitemap\";\n  })) {\n    return routes;\n  }\n  var _require = require(\"./views/Sitemap\"),\n    Sitemap = _require.Sitemap,\n    getNavOptions = _require.getNavOptions;\n  routes.children.push({\n    loadRoute: function loadRoute() {\n      return {\n        default: Sitemap,\n        getNavOptions: getNavOptions\n      };\n    },\n    route: \"_sitemap\",\n    contextKey: \"./_sitemap.tsx\",\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: []\n  });\n  return routes;\n}\nfunction appendUnmatchedRoute(routes) {\n  var userDefinedDynamicRoute = getUserDefinedDeepDynamicRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute: function loadRoute() {\n        return {\n          default: require(\"./views/Unmatched\").Unmatched\n        };\n      },\n      route: \"[...404]\",\n      contextKey: \"./[...404].tsx\",\n      dynamic: [{\n        name: \"404\",\n        deep: true\n      }],\n      children: [],\n      generated: true,\n      internal: true\n    });\n  }\n  return routes;\n}\n\nexport function getUserDefinedDeepDynamicRoute(routes) {\n  for (var route of (_routes$children = routes.children) != null ? _routes$children : []) {\n    var _routes$children;\n    if (route.generated) continue;\n    var opaqueRoute = stripInvisibleSegmentsFromPath(route.route);\n    var isDeepDynamic = matchDeepDynamicRouteName(opaqueRoute);\n    if (isDeepDynamic) {\n      return route;\n    }\n    if (matchGroupName(route.route)) {\n      var child = getUserDefinedDeepDynamicRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\nfunction withOptionalRootLayout(routes) {\n  if (!(routes != null && routes.length)) {\n    return null;\n  }\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n  return {\n    loadRoute: function loadRoute() {\n      return {\n        default: require(\"./views/Navigator\").DefaultNavigator\n      };\n    },\n    contextKey: \"./_layout.tsx\",\n    route: \"\",\n    generated: true,\n    dynamic: null,\n    children: routes\n  };\n}","map":{"version":3,"names":["getNameFromFilePath","matchDeepDynamicRouteName","matchDynamicName","matchGroupName","removeSupportedExtensions","stripGroupSegmentsFromPath","stripInvisibleSegmentsFromPath","getRecursiveTree","files","tree","name","children","parents","node","file","parts","normalizedName","split","currentNode","part","i","length","overwritten","contextKey","Error","existing","find","item","newNode","push","process","env","NODE_ENV","assertDeprecatedFormat","child","endsWith","ext","pop","getTreeNodesAsRouteNodes","nodes","map","treeNodeToRouteNode","flat","filter","Boolean","generateDynamicFromSegment","deepDynamicName","dynamicName","deep","generateDynamic","description","segment","collapseRouteSegments","route","replace","getDefaultInitialRoute","applyDefaultInitialRouteName","groupName","initialRouteName","undefined","loaded","loadRoute","unstable_settings","groupSpecificInitialRouteName","cloneGroupRoute","nextName","join","folderNodeToRouteNode","fileNodeToRouteNode","dynamic","multiGroup","includes","clones","v","trim","names","Set","clone","has","add","output","Array","isArray","contextModuleToFileNodes","contextModule","keys","key","default","error","console","warn","hasCustomRootLayoutNode","routes","match","treeNodesToRootRoute","treeNode","withOptionalRootLayout","processKeys","options","ignore","some","pattern","test","assertDuplicateRoutes","filenames","duplicates","filename","reduce","acc","Object","entries","forEach","count","getRoutes","getExactRoutes","appendSitemapRoute","appendUnmatchedRoute","getRoutesAsync","getExactRoutesAsync","getIgnoreList","treeNodes","contextModuleToTree","allowed","require","Sitemap","getNavOptions","generated","internal","userDefinedDynamicRoute","getUserDefinedDeepDynamicRoute","Unmatched","opaqueRoute","isDeepDynamic","DefaultNavigator"],"sources":["C:/react-project/rn-jobs/node_modules/expo-router/src/getRoutes.ts"],"sourcesContent":["import type { DynamicConvention, RouteNode } from \"./Route\";\nimport {\n  getNameFromFilePath,\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  removeSupportedExtensions,\n  stripGroupSegmentsFromPath,\n  stripInvisibleSegmentsFromPath,\n} from \"./matchers\";\nimport type { RequireContext } from \"./types\";\n\nexport type FileNode = Pick<RouteNode, \"contextKey\" | \"loadRoute\"> & {\n  /** Like `(tab)/index` */\n  normalizedName: string;\n};\n\ntype TreeNode = {\n  name: string;\n  children: TreeNode[];\n  parents: string[];\n  /** null when there is no file in a folder. */\n  node: FileNode | null;\n};\n\ntype Options = {\n  ignore?: RegExp[];\n};\n\n/** Convert a flat map of file nodes into a nested tree of files. */\nexport function getRecursiveTree(files: FileNode[]): TreeNode {\n  const tree = {\n    name: \"\",\n    children: [],\n    parents: [],\n    node: null,\n  };\n\n  for (const file of files) {\n    // ['(tab)', 'settings', '[...another]']\n    const parts = file.normalizedName.split(\"/\");\n    let currentNode: TreeNode = tree;\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n\n      if (i === parts.length - 1 && part === \"_layout\") {\n        if (currentNode.node) {\n          const overwritten = currentNode.node.contextKey;\n          throw new Error(\n            `Higher priority Layout Route \"${file.contextKey}\" overriding redundant Layout Route \"${overwritten}\". Remove the Layout Route \"${overwritten}\" to fix this.`\n          );\n        }\n        continue;\n      }\n\n      const existing = currentNode.children.find((item) => item.name === part);\n      if (existing) {\n        currentNode = existing;\n      } else {\n        const newNode: TreeNode = {\n          name: part,\n          children: [],\n          parents: [...currentNode.parents, currentNode.name],\n          node: null,\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    }\n    currentNode.node = file;\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDeprecatedFormat(tree);\n  }\n\n  return tree;\n}\n\nfunction assertDeprecatedFormat(tree: TreeNode) {\n  for (const child of tree.children) {\n    if (\n      child.node &&\n      child.children.length &&\n      !child.node.normalizedName.endsWith(\"_layout\")\n    ) {\n      const ext = child.node.contextKey.split(\".\").pop();\n      throw new Error(\n        `Using deprecated Layout Route format: Move \\`./app/${child.node.normalizedName}.${ext}\\` to \\`./app/${child.node.normalizedName}/_layout.${ext}\\``\n      );\n    }\n    assertDeprecatedFormat(child);\n  }\n}\n\nfunction getTreeNodesAsRouteNodes(nodes: TreeNode[]): RouteNode[] {\n  return nodes\n    .map((node) => treeNodeToRouteNode(node))\n    .flat()\n    .filter(Boolean) as RouteNode[];\n}\n\nexport function generateDynamicFromSegment(\n  name: string\n): DynamicConvention | null {\n  const deepDynamicName = matchDeepDynamicRouteName(name);\n  const dynamicName = deepDynamicName ?? matchDynamicName(name);\n\n  return dynamicName ? { name: dynamicName, deep: !!deepDynamicName } : null;\n}\n\nexport function generateDynamic(name: string): RouteNode[\"dynamic\"] {\n  const description = name\n    .split(\"/\")\n    .map((segment) => generateDynamicFromSegment(segment))\n    .filter(Boolean) as DynamicConvention[];\n  return description.length === 0 ? null : description;\n}\n\nfunction collapseRouteSegments(route: string) {\n  return stripGroupSegmentsFromPath(route.replace(/\\/index$/, \"\"));\n}\n\n/**\n * Given a route node and a name representing the group name,\n * find the nearest child matching the name.\n *\n * Doesn't support slashes in the name.\n * Routes like `explore/(something)/index` will be matched against `explore`.\n *\n */\nfunction getDefaultInitialRoute(node: RouteNode, name: string) {\n  return node.children.find(\n    (node) => collapseRouteSegments(node.route) === name\n  );\n}\n\nfunction applyDefaultInitialRouteName(node: RouteNode): RouteNode {\n  const groupName = matchGroupName(node.route);\n  if (!node.children?.length) {\n    return node;\n  }\n\n  // Guess at the initial route based on the group name.\n  // TODO(EvanBacon): Perhaps we should attempt to warn when the group doesn't match any child routes.\n  let initialRouteName = groupName\n    ? getDefaultInitialRoute(node, groupName)?.route\n    : undefined;\n  const loaded = node.loadRoute();\n\n  if (loaded.unstable_settings) {\n    // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n    initialRouteName =\n      loaded.unstable_settings.initialRouteName ?? initialRouteName;\n\n    if (groupName) {\n      // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n      const groupSpecificInitialRouteName =\n        loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n      initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n    }\n  }\n\n  return {\n    ...node,\n    initialRouteName,\n  };\n}\n\nfunction cloneGroupRoute(\n  node: RouteNode,\n  { name: nextName }: { name: string }\n): RouteNode {\n  const groupName = `(${nextName})`;\n  const parts = node.contextKey.split(\"/\");\n  parts[parts.length - 2] = groupName;\n\n  return {\n    ...node,\n    route: groupName,\n    contextKey: parts.join(\"/\"),\n  };\n}\n\nfunction folderNodeToRouteNode({\n  name,\n  children,\n}: TreeNode): RouteNode[] | null {\n  // Empty folder, skip it.\n  if (!children.length) {\n    return null;\n  }\n\n  // When there's a directory, but no layout route file (with valid export), the child routes won't be grouped.\n  // This pushes all children into the nearest layout route.\n  return getTreeNodesAsRouteNodes(\n    children.map((child) => {\n      return {\n        ...child,\n        name: [name, child.name].filter(Boolean).join(\"/\"),\n      };\n    })\n  );\n}\n\nfunction fileNodeToRouteNode(tree: TreeNode): RouteNode[] | null {\n  const { name, node, children } = tree;\n\n  if (!node) throw new Error(\"node must be defined\");\n\n  const dynamic = generateDynamic(name);\n\n  const groupName = matchGroupName(name);\n  const multiGroup = groupName?.includes(\",\");\n\n  const clones = multiGroup\n    ? groupName!.split(\",\").map((v) => ({ name: v.trim() }))\n    : null;\n\n  // Assert duplicates:\n  if (clones) {\n    const names = new Set<string>();\n    for (const clone of clones) {\n      if (names.has(clone.name)) {\n        throw new Error(\n          `Array syntax cannot contain duplicate group name \"${clone.name}\" in \"${node.contextKey}\".`\n        );\n      }\n      names.add(clone.name);\n    }\n  }\n\n  const output = {\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic,\n  };\n\n  if (Array.isArray(clones)) {\n    return clones.map((clone) =>\n      applyDefaultInitialRouteName(cloneGroupRoute({ ...output }, clone))\n    );\n  }\n\n  return [\n    applyDefaultInitialRouteName({\n      loadRoute: node.loadRoute,\n      route: name,\n      contextKey: node.contextKey,\n      children: getTreeNodesAsRouteNodes(children),\n      dynamic,\n    }),\n  ];\n}\n\nfunction treeNodeToRouteNode(tree: TreeNode): RouteNode[] | null {\n  if (tree.node) {\n    return fileNodeToRouteNode(tree);\n  }\n\n  return folderNodeToRouteNode(tree);\n}\n\nfunction contextModuleToFileNodes(\n  contextModule: RequireContext,\n  files: string[] = contextModule.keys()\n): FileNode[] {\n  const nodes = files.map((key) => {\n    // In development, check if the file exports a default component\n    // this helps keep things snappy when creating files. In production we load all screens lazily.\n    try {\n      if (process.env.NODE_ENV === \"development\") {\n        // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should\n        // filter the missing routes.\n        if (process.env.EXPO_ROUTER_IMPORT_MODE === \"sync\") {\n          if (!contextModule(key)?.default) {\n            return null;\n          }\n        }\n      }\n      const node: FileNode = {\n        loadRoute() {\n          return contextModule(key);\n        },\n        normalizedName: getNameFromFilePath(key),\n        contextKey: key,\n      };\n\n      return node;\n    } catch (error) {\n      // Probably this won't stop metro from freaking out but it's worth a try.\n      console.warn('Error loading route \"' + key + '\"', error);\n    }\n    return null;\n  });\n\n  return nodes.filter(Boolean) as FileNode[];\n}\n\nfunction hasCustomRootLayoutNode(routes: RouteNode[]) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  // This could either be the root _layout or an app with a single file.\n  const route = routes[0];\n\n  if (\n    route.route === \"\" &&\n    route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction treeNodesToRootRoute(treeNode: TreeNode): RouteNode | null {\n  const routes = treeNodeToRouteNode(treeNode);\n  return withOptionalRootLayout(routes);\n}\n\nfunction processKeys(files: string[], options: Options): string[] {\n  const { ignore } = options;\n\n  return files.filter((file) => {\n    return !ignore?.some((pattern) => pattern.test(file));\n  });\n}\n\n/**\n * Asserts if the require.context has files that share the same name but have different extensions. Exposed for testing.\n * @private\n */\nexport function assertDuplicateRoutes(filenames: string[]) {\n  if (process.env.NODE_ENV === \"production\") {\n    return;\n  }\n\n  const duplicates = filenames\n    .map((filename) => removeSupportedExtensions(filename))\n    .reduce((acc, filename) => {\n      acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n  Object.entries(duplicates).forEach(([filename, count]) => {\n    if (count > 1) {\n      throw new Error(`Multiple files match the route name \"${filename}\".`);\n    }\n  });\n}\n\n/** Given a Metro context module, return an array of nested routes. */\nexport function getRoutes(\n  contextModule: RequireContext,\n  options?: Options\n): RouteNode | null {\n  const route = getExactRoutes(contextModule, options);\n  if (!route) {\n    return null;\n  }\n\n  appendSitemapRoute(route);\n\n  // Auto add not found route if it doesn't exist\n  appendUnmatchedRoute(route);\n\n  return route;\n}\n\nexport async function getRoutesAsync(\n  contextModule: RequireContext,\n  options?: Options\n): Promise<RouteNode | null> {\n  const route = await getExactRoutesAsync(contextModule, options);\n  if (!route) {\n    return null;\n  }\n\n  appendSitemapRoute(route);\n\n  // Auto add not found route if it doesn't exist\n  appendUnmatchedRoute(route);\n\n  return route;\n}\n\nfunction getIgnoreList(options?: Options) {\n  const ignore: RegExp[] = [\n    /^\\.\\/\\+html\\.[tj]sx?$/,\n    ...(options?.ignore ?? []),\n  ];\n  return ignore;\n}\n\n/** Get routes without unmatched or sitemap. */\nexport function getExactRoutes(\n  contextModule: RequireContext,\n  options?: Options\n): RouteNode | null {\n  const treeNodes = contextModuleToTree(contextModule, options);\n  const route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\n\nfunction contextModuleToTree(contextModule: RequireContext, options?: Options) {\n  const allowed = processKeys(contextModule.keys(), {\n    ...options,\n    ignore: getIgnoreList(options),\n  });\n  assertDuplicateRoutes(allowed);\n  const files = contextModuleToFileNodes(contextModule, allowed);\n  return getRecursiveTree(files);\n}\n\nexport async function getExactRoutesAsync(\n  contextModule: RequireContext,\n  options?: Options\n): Promise<RouteNode | null> {\n  const treeNodes = contextModuleToTree(contextModule, options);\n  const route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\n\nfunction appendSitemapRoute(routes: RouteNode) {\n  if (\n    !routes.children.length ||\n    // Allow overriding the sitemap route\n    routes.children.some((route) => route.route === \"_sitemap\")\n  ) {\n    return routes;\n  }\n  const { Sitemap, getNavOptions } = require(\"./views/Sitemap\");\n  routes.children.push({\n    loadRoute() {\n      return { default: Sitemap, getNavOptions };\n    },\n    route: \"_sitemap\",\n    contextKey: \"./_sitemap.tsx\",\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: [],\n  });\n  return routes;\n}\n\nfunction appendUnmatchedRoute(routes: RouteNode) {\n  // Auto add not found route if it doesn't exist\n  const userDefinedDynamicRoute = getUserDefinedDeepDynamicRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute() {\n        return { default: require(\"./views/Unmatched\").Unmatched };\n      },\n      route: \"[...404]\",\n      contextKey: \"./[...404].tsx\",\n      dynamic: [{ name: \"404\", deep: true }],\n      children: [],\n      generated: true,\n      internal: true,\n    });\n  }\n  return routes;\n}\n\n/**\n * Exposed for testing.\n * @returns a top-level deep dynamic route if it exists, otherwise null.\n */\nexport function getUserDefinedDeepDynamicRoute(\n  routes: RouteNode\n): RouteNode | null {\n  // Auto add not found route if it doesn't exist\n  for (const route of routes.children ?? []) {\n    if (route.generated) continue;\n    const opaqueRoute = stripInvisibleSegmentsFromPath(route.route);\n    const isDeepDynamic = matchDeepDynamicRouteName(opaqueRoute);\n    if (isDeepDynamic) {\n      return route;\n    }\n    // Recurse through group routes\n    if (matchGroupName(route.route)) {\n      const child = getUserDefinedDeepDynamicRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\n\nfunction withOptionalRootLayout(routes: RouteNode[] | null): RouteNode | null {\n  if (!routes?.length) {\n    return null;\n  }\n\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n\n  return {\n    loadRoute: () => ({\n      default: (\n        require(\"./views/Navigator\") as typeof import(\"./views/Navigator\")\n      ).DefaultNavigator,\n    }),\n    // Generate a fake file name for the directory\n    contextKey: \"./_layout.tsx\",\n    route: \"\",\n    generated: true,\n    dynamic: null,\n    children: routes,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}